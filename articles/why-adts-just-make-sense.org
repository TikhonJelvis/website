* Why Algebraic Data Types *Just Make Sense*

** Products
 - pairs, structs, records

*** Pairs
  - pairs are a very natural starting point
  - going from scalar values (numbers) to pairs
  - pairs to records/structs is trivial
    - basic abstraction

*** Products
  - pairs have some nice behavior
  - defined by *projection functions*
    - *simplest* construct
  - easy to generalize to n-tuples and such

** Sums
  - variants

*** Duality
  - flip arrows for products
  - defined by *injection functions*
    - *simplest* construct
  - behaves very similarly to products!

** Symmetry
  - just like physics, symmetry is a *very good* thing
  - pops up all over the place

*** Construction/Deconstruction
  - pairs:
    - two arguments to construct
    - one value to deconstruct
  - variants:
    - one argument to construct
    - two values to deconstruct

*** Logic, Curry-Howard
  - and/or
  - inverses
  - good illustration of duality/symmetry

*** Sub-typing
  - similar to OOP inheritance
    - is-a relationship (?)
  - records can *grow*
  - variants can *shrink*
  - inverses!

*** Lenses/Prism
  - accessors:
    - getters/setters
    - C#-style properties
  - work for *records*
  - hey, maybe we can exploit duality!
    - prisms
    - TODO: figure out how prisms are dual to lenses
 
** Why this is important 
  - other languages feel like they are missing half the picture
  - simple design:
    - natural starting place
    - *very* simple steps

*** General Philosophy
  - languages: arbitrary vs elegant
    - ADTs are *elegant*
    - OOP/Go/C are *arbitrary*

*** Simplicity
  - Simple Made Easy
  - the very core of *simplicity*
  - types can be---and are!---simple
    - talk about Simple Made Easy
  - symmetry and duality point to simplicity
    - you get half for free!
    - language design: 50% less complexity (roughly)
